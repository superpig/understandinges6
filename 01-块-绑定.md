# 块绑定

以前变量声明的方式是JavaScript编程中诡异的一部分。在大部分基于C的语言中，变量（或者绑定）在声明的地方创建。然而在JavaScript中却不一样，你的变量在哪创建取决于你怎么去声明他们，ECMAScript6提供可选的方式，使得�控制作用域更加简单。这章将说明为什么传统的var声明会混乱，介绍ECMAScript6中的块级绑定，然后提供一些使用它们的最佳实践。

## Var声明和变量提升

使用var声明变量，不管实际声明的位置在哪，他们都好像在函数（或者全局作用域，如果在函数外面声明）顶部声明一样；这就是变量提升。为了说明变量提升的作用，请看下面的函数定义：

```js
function getValue(condition) {

    if (condition) {
        var value = "blue";

        // 其他代码

        return value;
    } else {

        // value变量以undefined的值存在

        return null;
    }

    // value变量以undefined的值存在
}
```
如果你不熟悉JavaScript，你可能认为value变量只会在if语句中condition为true情况下创建。实际上，无论condition是否为true，变量value都会被创建。在这种场景背后，JavaScript引擎改变了getValue函数，看起来如下：

```js
function getValue(condition) {

    var value;

    if (condition) {
        value = "blue";

        // 其他代码

        return value;
    } else {

        return null;
    }
}
```
变量的声明提升到了顶部，但初始化还是保留在原地。这意味着，在else分支中也可访问value变量。如果这里访问，变量的值为undefined，因为它没有被初始化。

JavaScript初级开发者通常要花一些时间适应声明提升，而且误解这种行为最终会造成bug。出于这个原因，ECMAScript6引入块级作用域选项，更有效的控制变量的生命周期。

## 块级声明

块级声明是指声明变量无法在指定的块级作用域之外被访问。块级作用域也被称为词法作用域，创建方式如下：

 1. 在一个函数里
 2. 在一个代码块中（用{和}字符标示代码块）

块级作用域是许多基于C的编程语言工作的方式，在ECMAScript6引入块级声明，目的是为了给JavaScript带来同样的灵活性（和一致性）。

 ## Let声明
 let声明语法和var一样。你基本上可以let替代var声明一个变量，但是限制变量的作用域只在当前的代码快中（以及稍后要讨论的一些其他的细微差别）。因为let声明不会不会被提升到封闭块的顶部，你可能想在代码块中首位放置let声明，这样在整个代码块中都可以被访问。这有一个例子：

```js
function getValue(condition) {

    if (condition) {
        let value = "blue";

        // 其他代码

        return value;
    } else {

        // 无法访问value变量

        return null;
    }

    // 无法访问value变量
}
```
这个版本的getValue函数的行为十分接近你所期待基于C的编程所表现的行为。因为变量使用let声明，而不是var，这个变量声明没有被提升到函数定义的顶部，而且一旦执行if代码块完，将无法访问value变量。如果if语句中的condition为false，value变量不会被声明和初始化。

## 没有重复声明

如果一个变量已经在作用域中定义了，然后在这个作用域中再使用let声明这个变量，这会抛出一个异常。例如：
```js
var count = 30;

// 语法错误
let count = 40;
```

在这个例子中，count变量被声明了两次：一次使用var，一次使用let。因为let不会在同一个作用域重复定义一个已经存在的变量，如果出现这种情况，let声明将会抛出一个异常。另一方面，如果let声明在子级块作用域中定义一个和父级块作用域相同名称的变量，这不会报错。示范如下：

```js
var count = 30;

// 不会抛出错误
if (condition) {

    let count = 40;

    // 其他代码
}
```

这个let声明不会报错，因为它是在if语句中创建的一个名为count的新变量，而不是在包围if语句的块级作用域中创建的count变量。在这个if块级作用域中，这个新变量会覆盖全局的count变量，直到程序执行离开这块级作用域，才可以访问这个全局count变量。

## 常量声明

你也可以在ECMAScript6中使用const声明语法定义变量。使用const声明的变量被认为是常量，这意味着它们的值一旦设定就不能更改了。因为这个原因，每个const变量必须在声明时赋值，如下例子所示：

```js
// 有效的变量
const maxItems = 30;

// 语法错误: 没有初始化
const name;
```
maxItems变量已经被初始化，所以的使用const声明不会有问题。但是如果你试图运行包含声明name代码的程序，name变量造成语法错误，因为name变量没有被初始化。

### 常量 VS let声明

常量和let声明一样，都是块级作用域声明。这意味着一旦程序执行流出声明它们所在的块级作用域，这些常量就不能被访问了，而且常量声明不会变量提升，示例如下面这个例子：

```js
if (condition) {
    const maxItems = 5;

    // 其他代码
}

// maxItems变量在这里不能被访问
```

在这段代码中，在if语句中声明了maxItems变量。一旦执行完这条语句，在这个块级作用域之外就不能访问maxItems。

和let声明另外一个相似之处是，在同一个作用域重复使用const声明定义一个变量，这抛出一个异常，不管那个变量是使用var（在全局或函数定义域）还是let（块级作用域）声明。例如，看下面这段代码：

```js
var message = "Hello!";
let age = 25;

// 下面的每个声明都会抛出一个异常
const message = "Goodbye!";
const age = 30;
```

这两个const声明单独存在时会生效，但是在这例子中，这两个变量在之前已经使用let和const声明，这样都不会如期工作。

尽管let和constcon有这么多相似之处，但是他们之间有一个很大区别需要记住。在严格模式和非严格模式中，如果试图给一个已经定义的const变量重新赋值，这会报错：

```js
const maxItems = 5;

maxItems = 6;      // 报错
```

和其他编程语言中的常量十分相似，maxItems变量之后不能再分配新的值。然而，和其他编程语言的常量不一样的是，如果这个常量是一个对象，它包含的值可以被修改。

### 用const声明对象

const声明阻止修改绑定，而不是值本身。这意味着对象的const声明不会阻止修改那些对象的值。例如：

```js
const person = {
    name: "Nicholas"
};

// 正常运行
person.name = "Greg";

// 抛出一个错误
person = {
    name: "Greg"
};
```

在这里，创建person常量，初始化为只有一个属性的对象。你可以改变person.name的值，并且不会报错，因为这只是改变了person所包含的值，而不是person绑定的值。当这段代码试图给person分配一个值时（试图改变person的绑定），将会抛出一个错误。const声明在对象上工作的细节很容易被误解。必须记住：const只会阻止修改对象的绑定，而不是绑定在它上面的值。
