# 块绑定

以前变量声明的方式是JavaScript编程中诡异的一部分。在大部分基于C的语言中，变量（或者绑定）在声明的地方创建。然而在JavaScript中却不一样，你的变量在哪创建取决于你怎么去声明他们，ECMAScript6提供可选的方式，使得�控制作用域更加简单。这章将说明为什么传统的var声明会混乱，介绍ECMAScript6中的块级绑定，然后提供一些使用它们的最佳实践。

## Var声明和变量提升

使用var声明变量，不管实际声明的位置在哪，他们都好像在函数（或者全局作用域，如果在函数外面声明）顶部声明一样；这就是变量提升。为了说明变量提升的作用，请看下面的函数定义：

```js
function getValue(condition) {

    if (condition) {
        var value = "blue";

        // 其他代码

        return value;
    } else {

        // value变量以undefined的值存在

        return null;
    }

    // value变量以undefined的值存在
}
```
如果你不熟悉JavaScript，你可能认为value变量只会在if语句中condition为true情况下创建。实际上，无论condition是否为true，变量value都会被创建。在这种场景背后，JavaScript引擎改变了getValue函数，看起来如下：

```js
function getValue(condition) {

    var value;

    if (condition) {
        value = "blue";

        // 其他代码

        return value;
    } else {

        return null;
    }
}
```
变量的声明提升到了顶部，但初始化还是保留在原地。这意味着，在else分支中也可访问value变量。如果这里访问，变量的值为undefined，因为它没有被初始化。

JavaScript初级开发者通常要花一些时间适应声明提升，而且误解这种行为最终会造成bug。出于这个原因，ECMAScript6引入块级作用域选项，更有效的控制变量的生命周期。

## 块级声明

块级声明是指声明变量无法在指定的块级作用域之外被访问。块级作用域也被称为词法作用域，创建方式如下：

 1. 在一个函数里
 2. 在一个代码块中（用{和}字符标示代码块）

块级作用域是许多基于C的编程语言工作的方式，在ECMAScript6引入块级声明，目的是为了给JavaScript带来同样的灵活性（和一致性）。

 ## Let声明
 let声明语法和var一样。你基本上可以let替代var声明一个变量，但是限制变量的作用域只在当前的代码快中（以及稍后要讨论的一些其他的细微差别）。因为let声明不会不会被提升到封闭块的顶部，你可能想在代码块中首位放置let声明，这样在整个代码块中都可以被访问。这有一个例子：

```js
function getValue(condition) {

    if (condition) {
        let value = "blue";

        // 其他代码

        return value;
    } else {

        // 无法访问value变量

        return null;
    }

    // 无法访问value变量
}
```
这个版本的getValue函数的行为十分接近你所期待基于C的编程所表现的行为。因为变量使用let声明，而不是var，这个变量声明没有被提升到函数定义的顶部，而且一旦执行if代码块完，将无法访问value变量。如果if语句中的condition为false，value变量不会被声明和初始化。

## 没有重复声明

如果一个变量已经在作用域中定义了，然后在这个作用域中再使用let声明这个变量，这会抛出一个异常。例如：
```js
var count = 30;

// 语法错误
let count = 40;
```

在这个例子中，count变量被声明了两次：一次使用var，一次使用let。因为let不会在同一个作用域重复定义一个已经存在的变量，如果出现这种情况，let声明将会抛出一个异常。另一方面，如果let声明在子级块作用域中定义一个和父级块作用域相同名称的变量，这不会报错。示范如下：

```js
var count = 30;

// 不会抛出错误
if (condition) {

    let count = 40;

    // 其他代码
}
```

这个let声明不会报错，因为它是在if语句中创建的一个名为count的新变量，而不是在包围if语句的块级作用域中创建的count变量。在这个if块级作用域中，这个新变量会覆盖全局的count变量，直到程序执行离开这块级作用域，才可以访问这个全局count变量。

## 常量声明

你也可以在ECMAScript6中使用const声明语法定义变量。使用const声明的变量被认为是常量，这意味着它们的值一旦设定就不能更改了。因为这个原因，每个const变量必须在声明时赋值，如下例子所示：

```js
// 有效的变量
const maxItems = 30;

// 语法错误: 没有初始化
const name;
```
maxItems变量已经被初始化，所以的使用const声明不会有问题。但是如果你试图运行包含声明name代码的程序，name变量造成语法错误，因为name变量没有被初始化。

### 常量 VS let声明

常量和let声明一样，都是块级作用域声明。这意味着一旦程序执行流出声明它们所在的块级作用域，这些常量就不能被访问了，而且常量声明不会变量提升，示例如下面这个例子：

```js
if (condition) {
    const maxItems = 5;

    // 其他代码
}

// maxItems变量在这里不能被访问
```

在这段代码中，在if语句中声明了maxItems变量。一旦执行完这条语句，在这个块级作用域之外就不能访问maxItems。

和let声明另外一个相似之处是，在同一个作用域重复使用const声明定义一个变量，这抛出一个异常，不管那个变量是使用var（在全局或函数定义域）还是let（块级作用域）声明。例如，看下面这段代码：

```js
var message = "Hello!";
let age = 25;

// 下面的每个声明都会抛出一个异常
const message = "Goodbye!";
const age = 30;
```

这两个const声明单独存在时会生效，但是在这例子中，这两个变量在之前已经使用let和const声明，这样都不会如期工作。

尽管let和constcon有这么多相似之处，但是他们之间有一个很大区别需要记住。在严格模式和非严格模式中，如果试图给一个已经定义的const变量重新赋值，这会报错：

```js
const maxItems = 5;

maxItems = 6;      // 报错
```

和其他编程语言中的常量十分相似，maxItems变量之后不能再分配新的值。然而，和其他编程语言的常量不一样的是，如果这个常量是一个对象，它包含的值可以被修改。

### 用const声明对象

const声明阻止修改绑定，而不是值本身。这意味着对象的const声明不会阻止修改那些对象的值。例如：

```js
const person = {
    name: "Nicholas"
};

// 正常运行
person.name = "Greg";

// 抛出一个错误
person = {
    name: "Greg"
};
```

在这里，创建person常量，初始化为只有一个属性的对象。你可以改变person.name的值，并且不会报错，因为这只是改变了person所包含的值，而不是person绑定的值。当这段代码试图给person分配一个值时（试图改变person的绑定），将会抛出一个错误。const声明在对象上工作的细节很容易被误解。必须记住：const只会阻止修改对象的绑定，而不是绑定在它上面的值。

## 暂时盲区

使用let或者const声明的变量在被声明之前都不能被访问。如果试图去访问这个变量，会导致一个应用错误，即使使用常用的安全操作，比如在这例子中typeof:

```js
if (condition) {
    console.log(typeof value);  // 引用错误
    let value = "blue";
}
```

这里，使用let定义value变量，并且进行了初始化，但是那条语句不会被执行，因为那条语句的前一行已经抛出异常。这个问题是value存在于暂时盲区（TDZ）中，暂时盲区名词来源于JavaScript社区。“暂时盲区”名词在ECMASCript规范中没有定义，但是这个术语经常用来解释，为什么let和const定义变量在声明之前不能被访问。尽管上面的例子已经展示let的所有使用方法，这部分覆盖了一些由“暂时盲区”造成的声明位置的细节，同样情况也适用于const。

当JavaScript引擎遍历即将到来的块级作用域，发现一个变量声明，它要么把这个变量提升到函数或者全局作用域的顶部（对于var声明），或者是把这声明放在“暂时盲区”中（对于let和const声明）。任何试图访问“暂时盲区”中的变量的行为，都会导致执行错误。这个变量只有从“暂时盲区”区域移除之后，也就是程序执行到这个变量声明的地方，这才可以安全地使用该变量。

对于let或者const声明的变量，任何时候试图在定义它之前去调用它，都符合上述情况。正如上面例子展示，这种情况甚至适用于常见的typeof操作。但是你可以在变量声明的块级作用域之外，对该变量使用typeof操作，尽管你得不到想要的结果。看下这段代码：

```js
console.log(typeof value);     // "undefined"

if (condition) {
    let value = "blue";
}
```
当typeof操作执行时，value变量不在“暂时盲区”中，因为这个操作执行在value声明的块级作用域之外。这意味着value没有绑定值，typeof只是简单的返回"undefined"。

“暂时盲区”只是块级作用域绑定的一个特殊的方面，另外一个特殊的方面发生在循环语句中。
