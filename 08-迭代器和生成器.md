## 迭代器（Iterators）和生成器（Generators）

许多编程语言已经从使用`for`循环遍历数据过渡，为了使用以编程方式返回集合中下一项的迭代器对象，它要求初始化变量去追踪集合中的位置。迭代器让操作集合数据更加容易，而且ECMAScript 6给JavaScript添加了迭代器。结合新的数组方法和新的集合类型（比如sets和maps），迭代器是高效处理数据的关键，而且你将在语言的许多其他部分找到它们的痕迹。有一个新的`for-of`循环和迭代器一起使用，spread（`...`）操作符也使用迭代器，而且迭代器甚至让异步编程更简单。

这章涵盖迭代器的许多使用，但是首先，要理解迭代器添加到JavaScript背后的历史。

## 循环问题

如果你曾经写过JavaScript，你可能写过像这样的代码：

```js
var colors = ["red", "green", "blue"];

for (var i = 0, len = colors.length; i < len; i++) {
    console.log(colors[i]);
}
```

标准的`for`循环使用`i`变量追踪`colors`数组中的索引。如果`i`不大于数组长度（储存在`len`），每次循环执行，`i`值自增。

然而这个循环不是十分明了，当你嵌套它们而且需要追踪多个变量时，循环就会变得复杂。额外的复杂可能导致错误，而且`for`循环的样板性质会导致自身出现更多的错误，因为类似的代码要在多个地方写。迭代器正是为了解决这个问题。

## 什么是迭代器

迭代器只是拥有具体接口的对象，它是为迭代而设计的。所有的迭代器都有一个`next()`方法，该方法返回一个结果对象。这个结果对象有两个属性：`value`，它是下一个值，以及`done`，它是boolean值，没有值返回时为true。迭代器在集合内维护了一个内部的位置指针，而且每次调用`next()`方法，它返回下一个合适的值。

如果你在返回最后一个值之后调用`next()`，这个方法返回`done`为`true`，而且`value`包含迭代器的返回值。那个返回值不是数据集合的一部分，而是最后一个关联数据，或者如果不存在这样的数据则为`undefined`。迭代器的返回值类似于函数的返回值，它是给调用者传递信息最后的方式。

考虑到这一点，使用ECMAScript 6创建迭代就十分清晰了：

```js
function createIterator(items) {

    var i = 0;

    return {
        next: function() {

            var done = (i >= items.length);
            var value = !done ? items[i++] : undefined;

            return {
                done: done,
                value: value
            };

        }
    };
}

var iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// 所有的再次调用
console.log(iterator.next());           // "{ value: undefined, done: true }"
```

`createIterator()`函数返回一个带有`next()`方法的对象。每次调用该方法，`items`数组的下一个值作为`value`返回。当`i`是3时，`done`变为true，而且三元条件操作符设置`value`为`undefined`。这两个结果满足ECMAScript 6中迭代器的特殊的末尾用例，即在遍历最后一个数据之后调用迭代器的`next()`方法。

如这个示例所示，编写符合ECMAScript 6规则的迭代器有一点复杂。

幸运地是，ECMAScript 6也提供了生成器，让创建迭代器对象更加简单。

## 什么是生成器

生成器是一个返回迭代器的函数。生成器函数在`function`关键字之后由星号字符表示，并且使用新的`yield`关键字。星号`*`直接挨着`function`或者中间有一些空白都没有关系，如这个示例：

```js
// 生成器
function *createIterator() {
    yield 1;
    yield 2;
    yield 3;
}

// 生成器如常规函数一样调用，但是会返回迭代器
let iterator = createIterator();

console.log(iterator.next().value);     // 1
console.log(iterator.next().value);     // 2
console.log(iterator.next().value);     // 3
```

`createIterator()`之前的`*`让这个函数为生成器。`yield`关键字也是ECMAScript 6新加的，它在调用`next()`时，指定生成的迭代器的返回值，按照它们应该返回的顺序。在成功调用`next()`方法之后，这个示例中生成的迭代器有三个不同的返回值：首先是`1`，然后是`2`，最后是`3`。生成器的调用和任何其他函数一样，像创建`iterator`所示。

也许生成器函数最有趣的方面是在每个`yield`语句只有，他们会停止执行。比如，在这段代码`yield 1`执行之后，这个函数不会执行任何其他内容，直到调用迭代器的`next()`方法。到那个时候，`yield 2`执行。在函数中间停止执行的能力十分强大，导致了生成器函数的一些有趣使用（在“高级迭代功能”一节中探讨）。

`yield`关键字可以和任何值或者表达式一起使用，所以你可以编写生成器函数，将每项添加到迭代器，而不必逐个列举它们。比如，有一种方式，你可以在`for`循环内部使用`yield`：

```js
function *createIterator(items) {
    for (let i = 0; i < items.length; i++) {
        yield items[i];
    }
}

let iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// 对于所有的再次调用
console.log(iterator.next());           // "{ value: undefined, done: true }"
```

这个实例中，将称之为`items`的数组传递给`createIterator()`生成器函数。在这个函数内，一个`for`循环会在循环的进行时，将数组中的元素yields到迭代器中。每次遇到`yield`，循环停止，每次在`iterator`上调用`next()`，循环接收到下一个`yield`语句。

生成器函数是ECMAScript 6中的一个重要特性，因为它们只是函数，它们可以用在所有相同的地方。这节的其余部分关注于编写迭代器的其他有用方式。

`yield`关键字只能在生成器内部使用。其他地方使用`yield`是一种语法错误，包括生成器内部的函数，比如：

```js
function *createIterator(items) {
    items.forEach(function(item) {  
        // 语法错误
        yield item + 1; 
    }); 
}
```

即使`yield`技术上在`createIterator()`内部，这段代码是一个语法错误，因为`yield`不能跨越函数边界。通过这种方式，`yield`类似于`return`，在一个嵌套的函数内不能为它的包含函数返回值。

### 生成器函数表达式

只要在`function`关键字和开括号之间包括一个星号（`*`）字符，你就可以使用函数表达式创建生成器。比如：

```js
let createIterator = function *(items) {
    for (let i = 0; i < items.length; i++) {
        yield items[i];
    }
};

let iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// 对于所有的进一步调用
console.log(iterator.next());           // "{ value: undefined, done: true }"
```

在这段代码中，`createIterator()`是一个生成器函数表达式而不是一个函数声明。星号在函数和开头的括号之间，因为函数表达式是匿名的。另外，这个示例和之前版本的`createIterator()`函数是一样的，也使用`for`循环。

创建的箭头函数不可能是生成器。

### 生成器对象的方法

因为生成器只是函数，他们也可以添加到对象。比如，你可以使用函数表达式以 ECMAScript 5对象字面量构建生成器：

```js
var o = {

    createIterator: function *(items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i];
        }
    }
};

let iterator = o.createIterator([1, 2, 3]);
```

你也可以通过在方法名前加上星号（`*`）使用ECMAScript 6的缩写方法：

```js
var o = {

    *createIterator(items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i];
        }
    }
};

let iterator = o.createIterator([1, 2, 3]);
```

这些示例功能上等效于“生成器函数表达式”章节的示例；它们只是使用了不同的语法。在缩写版本中，因为`createIterator()`没有使用`function`关键字定义，星号直接放置在方法名之前，尽管你可以在星号和方法名之间留下空格。




