# 用模块封装代码

JavaScript的“共享一切”方法来加载代码是语言中最容易出错和混乱的方面之一。其他语言使用诸如包之类的概念来定义代码作用域，但是在ECMAScript 6之前，应用中每个文件定义的内容共享一个全局作用域。随着web应用程序变得越来越复杂，并且开始使用更多的JavaScript代码，那种方式会导致一些问题，如命名冲突和安全隐患。ECMAScript 6的一个目标就是解决作用域问题，并且为JavaScript应用带来一些秩序。这就是为什么引入模块。

## 模块是什么？

*模块*是以不同模式加载的JavaScript文件（和scripts相反，它们以JavaScript工作的原始方式加载）。这种不同的模式是有必要的，因为模块具有与scripts非常不同的语义：

 1. 在严格模式下，模块代码自动运行，而且没有办法选择退出严格模式。
 2. 在模块的顶层创建变量不会自动添加到共享全局作用域。它们只存在于模块的顶级作用域。
 3. 模块顶级的`this`是`undefined`。
 4. 模块代码里面不允许HTML样式的注释（JavaScript的早期浏览器遗留的功能）。
 5. 模块必须将任何可用于代码的东西导出到模块之外。
 6. 模块可以导入其他模块的绑定。
 
这些差异咋一看似乎很小，但是它们在加载和评估JavaScript代码方面代表着重要的变化，我将在本章讨论这些。模块的实际功能是仅导出和导入所需的绑定，而不是文件中的所有内容。

理解导入和导出是理解模块和scripts差异的基础。

## 基本导出（Exporting）

你可以使用`export`关键字对其他模块暴露要发布的代码部分。在最简单的场景里，你可以把`export`放在任何变量、函数或者class声明前面，从模块里导出它，比如：

```js
// 导出数据
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// 导出函数
export function sum(num1, num2) {
    return num1 + num1;
}

// 导出class
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

// 这是个函数是模块的私有函数
function subtract(num1, num2) {
    return num1 - num2;
}

// 定义一个函数...
function multiply(num1, num2) {
    return num1 * num2;
}

// ...之后导出它
export { multiply };

```

这个示例中有一些地方需要注意。首先，除了`export`关键字，每个声明和原有声明完全一样。每个导出的函数或者class也有名称；这是因为导出的函数和类声明需要名称。你不能使用这个语法导出匿名函数或者classes，除非你使用`default`关键字（在模块章节的默认值部分详细讨论）。

接着，讨论下`multiply()`函数，定义它时没有导出。这样是可行的，因为你没必要总是导出声明：你也可以导出引用。最后，注意这个示例没有导出`subtract()`函数。在模块之外不能访问这个函数，因为未明确导出的任何变量、函数或者classes保持私有。

## 基本导出（Importing）
一旦你有导出的模块，你可以在另外的模块中使用`import`关键字访问功能。`import`语句的两部分是你要导入的标识符以及要导入标识符的模块。这是语句的基本形式：

```js
import { identifier1, identifier2 } from "./example.js";
```

`import`之后的大括号表示从给定模块导入的绑定。关键字`from`表示导入给定绑定的模块。模块由表示模块路径的字符串指定（成为模块指定符）。浏览器使用同样的路径格式，你可以传递给`<script>`元素，这意味着你必须包含文件扩展名。另外一方面，Node.js遵循它的传统约定，基于文件系统的前缀区分本地文件和包。比如，`example`是一个包，而`./example.js`是一个本地文件。

import的绑定列表看起来和结构对象类似，但它们不是同一个概念。

从模块中导入绑定时，绑定的行为就像使用`const`定义一样。这意味着，你不能使用相同名称定义另外一个变量（包括导入相同名称的另一个绑定），在`import`语句之前使用该标识符，或者改变它的值。

### 导入单个绑定

假设基础模块部分的第一个示例是在文件名为`example.js`的模块内。你可以以多种方式导入和使用那个模块。比如，你可以只导入一个标识符：

```js
// 只导入一个
import { sum } from "./example.js";

console.log(sum(1, 2));     // 3

sum = 1;        // 错误
```

尽管`example.js`导出不止一个函数，但是这个示例只导入`sum()`函数。如果你想给`sum`赋新值，结果会报错，因为你不能对导入绑定重新赋值。

确保在你导入文件的开头包含`/`，`./`或者`../`，以便在浏览器和Node.js之间实现最佳兼容性。

### 导入多个绑定

如果你想从示例模块中导入多个绑定，你可以明确列出它们，如下：

```js
// 导入多个模块
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
```

这里，从示例模块中导入三个绑定：`sum`，`multiple`和`magicNumber`。然后使用它们，就像它们在本地定义一样。

### 导入整个模块
还有一个特殊情况，允许你将整个模块作为单个对象导入。所有的导出都可以作为该对象的属性使用。比如：

```js
// 导入所有内容
import * as example from "./example.js";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
```

在这段代码中，`example.js`模块的所有导出绑定加载到一个称之为`example`的对象上。这个命名的exports（`sum()`函数，`multiple()`函数和`magicNumber`）作为`example`的属性被访问。这种导入形式称之为命名*空间导入*，因为`example`对象在`example.js`文件内不存在，而是创建作为example.js的所有导出成员的命名空间对象。

然而，请记住，无论你在`import`语句中使用一个模块多少次，这个模块只会执行一次。导入模块的代码执行之后，将实例化的模块保存在内存中，无论什么时候另一个`import`语句引用它，就会重复利用这个实例化的模块。思考以下代码：

```js
import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
```

即使在这个模块里有三个`import`声明，`example.js`只会执行一次。如果同一个应用中的其他模块想从`example.js`导入绑定，那些模块将会使用这段代码使用的模块实例。

### 模块语法限制
`export`和`imort`的一个重要限制是必须在其他语句和函数之外使用。比如，这段代码将会报语法错误：

```js
if (flag) {
    export flag;    // 语法错误
}
```

`export`语句在`if`语句内，这是不允许的。导出不能以任何方式有条件地或者动态地完成。模块语法存在的一个原因是为了让JavaScript引擎静态地判断要导出的内容。因此，你只能在模块的顶部使用`export`。

同样地，你不能在语句内使用`import`；你只能在顶部使用它。这意味着这段代码也会报语法错误：

```js
function tryImport() {
    import flag from "./example.js";    // 语法错误
}
```

你不能动态地导入绑定，因为你不能动态导出绑定。`export`和`import`关键字设计为静态的，因此像文本编辑器这样的工具可以很容易地从模块中得知哪些信息可用。

### 导入绑定的微妙怪癖

ECMAScript 6的`import`语句对变量，函数和classes创建了只读绑定，而不是想普通变量一样简单地引用原始绑定。即使导入绑定的模块不能改变绑定的值，但是导出那个标识的模块可以。比如，假设你想使用这个模块：

```js
export var name = "Nicholas";
export function setName(newName) {
    name = newName;
}
```

当你导入这两个绑定时，`setName()`函数可以改变`name`的值：

```js
import { name, setName } from "./example.js";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // error
```

`setName("Greg")`调用将会返回导出`setName()`的模块，并在这个模块中执行，将`name`设置为 "Greg"。请注意，这个更改会自动反映在导入的`name`绑定上。因为对于导出的`name`标识，`name`是局部名称。上面代码使用的`name`和导入的模块中使用的`name`不是同一个。

## 重命名导出和导入

有时候，你可能不想使用导入的模块中变量，函数或class的原始名称。幸运的是，你可以在导出和导入阶段更改一个导出的名称。

在第一种情况下，假设你有一个函数，你想使用不同的名称导出。你可以使用`as`关键字指定该函数在模块外部被称为的名称：

```js
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
```

这里，`sum()`函数（`sum`是*局部名称*）作为`add()`（`add`是*导出名称*）导出。这意味着当另一个模块想导入这个函数时，它将必须使用名称`add`：


```js
import { add } from "./example.js";
```

如果模块导入这个函数想使用不同的名称，它可以使用`as`:

```js
import { add as sum } from "./example.js";
console.log(typeof add);            // "undefined"
console.log(sum(1, 2));             // 3
```

这段代码导入`add()`函数，使用*导入名称*，并且重命名为`sum()`（本地名称）。这意味在这个模块中没有命名为`add`的标识。

## 模块中默认值

对于从模块中导出和导入默认值，模块语法是有优化的，这种模式在其他模块系统中也十分常见，比如CommonJS（在浏览器之外使用的另一种JavaScript规范）。模块的*默认值*是使用`default`关键字指定的单一变量，函数或者class，而且每个模块你只能设置一个默认导出。对多个导出使用`default`关键字是语法错误。

### 导出默认值

这里有一个简单的示例，使用`default`关键字：

```js
export default function(num1, num2) {
    return num1 + num2;
}
```

这个模块导出一个函数作为它的默认值。`default`关键字表示这是一个默认导出。这个函数不要求名称，因为模块本身代表这个函数。

你也可以指定一个标识作为默认导出，通过在`export default`之后放置它，比如：

```js
function sum(num1, num2) {
    return num1 + num2;
}

export default sum;
```

这里，首先定义`sum()`函数，之后作为模块的默认值导出。如果需要计算默认值，你可能想选择这种方法。

第三种指定标识符作为默认导出的方法是通过使用重命名语法，如下：

```js
function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
```

在重命名的导出中，标识符`default`具有特殊意义，表示值因为模块的默认值。因为`default`是JavaScript的关键字，他不能用作于变量，函数或者类名（它可以用作属性名）。所以使用`default`重命名导出是一个特殊情况，用于创建与定义非默认导出的一致性。如果你想使用单个`export`语句一次性指定多个导出，包括默认值，这种语法是有用的。

### 导入默认值

你可以使用如下语法，从模块中导入默认值：

```js
// 导入默认值default
import sum from "./example.js";

console.log(sum(1, 2));     // 3
```

这个import语句从`example.js`模块导入默认值。注意没有使用大括号，不像你看到的非默认导入。本地名称`sum`表示模块导出的默认函数。这种语法是最简洁的，而且ECMAScript 6的创建者期待他成为Web上导入的主要形式，这允许你使用已经存在的对象。

对于同时导出一个默认绑定和一个或多个非默认绑定的模块，你可以使用一个语句导入所有的导出绑定。比如，假设你有这个模块：

```js
export let color = "red";

export default function(num1, num2) {
    return num1 + num2;
}
```

你可以使用如下`import`语句，导入`color`和默认函数：

```js
import sum, { color } from "./example.js";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

逗号分隔默认的本地名称与非默认值，非默认值也由大括号括起来。请记住，默认值必须在import语句中的非默认值之前。

与导出默认值一样，你也可以使用重命名语法导入默认值：

```js
// 等效于前一个例子
import { default as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```

在这段代码中，默认导出（`default`）重命名为`sum`，而且还会导入额外的`color`。此示例与上述示例相当。
