# 字符串和正则表达式

字符串可以说是编程中最重要的数据类型。他们几乎存在每个高级编程语言中，高效地使用字符串是开发者创建有用的程序的基础。通过扩展，正则表达式十分重要，因为正则表达式给开发者提供的额外的功能操作字符串。考虑到这些事实，ECMAScript 6的创建者通过增加新功能和长期确实的功能，改善字符串类型和正则表达式。这章将介绍这两种类型的变化。

## 更好的Unicode支持

在ECMAScript 6之前，JavaScript字符串是16位字符编码（UTF-16）。每16位序列为一个字符串的代码单元。所有的字符串属性和方法，比如`length`属性和`charAt()`，都是基于这些16位的代码单元。当然，使用16位字符编码足以包含任何字符。由于Unicode引进扩展字符，16位字符编码不再满足需求。

### UTF-16 码点

限制字符的长度为16位不可能满足Unicode的目标，既给全世界的每一个字符提供唯一的编号。这些唯一的编号，被称为*码点*   ，他们都是从0开始的简单数字。码点是你们认为的字符代码，其中一个数标识一个字符。字符串编码必须将代码点编码为内部一致的代码单元。对于UTF-16，码点可以组成许多代码单元。

UTF-16中的前2^16个码点代表单个的16位代码单元。这区间称为*基本平面*  (BMP)。之外的字符都放在*辅助平面* ，*辅助平面* 的码点不只是16位。UTF-16为了解决这个问题引入*“代理对”* ，单码点用两个16位代码单元表示。这就意味着字符串中任何单字符，要么是基本平面字符集中一个代码单元，总共16位，要么是辅助平面字符集的的两个单元，总共32位。

在ECMAScript 5中，所有的字符操作基于16位代码单元工作，意味着在获取包含“代理对”的UTF-16编码字符串时，你可能得到出乎意料的结果，比如这个例子：

```js
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""
console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
```

单个Unicode字符`“𠮷”`使用代理对，因此，JavaScript字符操作在处理这个字符串时，将把它视为两个16位的字符。这表示：

 - `text`的长度为2，即使它应该是1。
 - 正则表达式不能匹配单字符，因为它会认为有两个字符。
 - `charAt()`不能返回有效的字符串，两个16位字符都不符合可打印的字符串

`charCodeAt()`方法也不能识别这个字符。它能对每个代码单元返回准确的16位数，但这是你在ECMAScript 5中最有可能得到`text`的真实值的方法。

另一方面，ECMAScript 6强制UTF-16字符串编码来解决这些问题。标准的字符串操作基于这种字符编码，这表示JavaScript可以支持专用于“代理对”的功能。本节的其余部分将讨论该功能的几个关键示例。

### codePointAt()方法

codePointAt()方法是ECMAScript 6为了完全支持UTF-16新添加的一个方法，它通过给定的一个字符串中的位置去匹配，取出Unicode码点。这个方法接收的是代码单元的位置，而不是字符的位置，并且返回一个整数值，比如示例中的这些`console.log()`:

```js
var text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```

除了non-BMP的字符集，`codePointAt()`方法和`charCodeAt()`方法返回值相同，`text`中的第一个字符是non-BMP字符，所以它是由两个代码单元组成，表示`length`属性的值为3，而不是2。`charCodeAt()`方法只返回位置为0的代码单元，但是codePointAt()返回完整的码点，即使码点跨越多个代码单元。两个方法都对位置1（第一个字符的第二个代码单元）和位置2（`“a”`字符）返回了相同的值。

在字符上调用`codePointAt()`是检验字符是否由一个或者两个码点表示的最简便方法。你可以写这个函数去检验：

```js
function is32Bit(c) {
    return c.codePointAt(0) > 0xFFFF;
}

console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false
```

16位字符的上限用十六进制表示为`FFFF`，所以任何在FFFF之上的码点必须由两个代码单元表示，总共32位。

### String.fromCodePoint()方法
当ECMASCript提供某种方式做某件事时，它也会提供一种方式做相反的事情。你能够使用`codePointAt()`方法提取字符串中某个字符的码点，同时，`String.fromCodePoint()`可以通过提供的码点产生一个单字符的字符串。例如：

```js
console.log(String.fromCodePoint(134071));  // "𠮷"
```

`String.fromCodePoint()`是`String.fromCharCode()`方法更加完整的版本。这两个方法对所有在BMP中的字符中是一样的，只有当传入非BMP中字符的码点，才会有差别。

### normalize()方法

Unicode另外一个有趣的方面是，为了满足排序或其他基于比较的操作的目的，不同的字符被认为是相等的。有两种方式去定义这些关系。第一种，* 典型等价*表示两个码点序列在所有方面是可互换的。例如，两个字符的组合可以规范地等价为一个字符。第二种关系是兼容等价。两个码点的兼容序列看起来不同，但是在某些场景是可互换的。

由于这些关系，基本上表示相同文本的两个字符串可以包含不同的码点序列。比如，字符"æ"和两个字符串"ae"可以换使用，但是严格意义上不同，除非用某种标准化。

给字符串提供了`ECMAScript`方法，ECMAScript 6支持Unicode标准形式。这个方法可选择性接受一个单一字符串参数，表示使用下面某一种Unicode标准形式：

 - 规范形式典型组合（"NFC"），默认使用
 - 规范形式典型分解（"NFD"）
 - 规范形式兼容组合（"NFKC"）
 - 规范形式兼容分解（"NFKD"）

解释四种形式的差别已经超出了本书的范围。只要记住，当比较字符串时，两个字符串必须标准化为同一种形式。比如：

```js
var normalized = values.map(function(text) {
    return text.normalize();
});

normalized.sort(function(first, second) {
    if (first < second) {
        return -1;
    } else if (first === second) {
        return 0;
    } else {
        return 1;
    }
});
```

这段代码把values数组中的字符串转化为标准形式，所以，这个数组可以正确排序。你可以通过把调用`normalize()`放在比较函数中，然后排序原始数组，如下：

```js
values.sort(function(first, second) {
    var firstNormalized = first.normalize(),
        secondNormalized = second.normalize();

    if (firstNormalized < secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
```

同样，注意这段代码最重要的部分是，`first`和`second`规范化为同一种形式。这些例子使用了默认的NFC，但是你可以很容易指定其他规范形式，比如：

```js
values.sort(function(first, second) {
    var firstNormalized = first.normalize("NFD"),
        secondNormalized = second.normalize("NFD");

    if (firstNormalized < secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
```

如果你之前从来没有考虑过Unicode规范，现在你可能不大使用这个方法。但是如果你曾经开发过国际应用，你肯定会发现`normalize()`方法十分有用。

ECMAScript 6在支持Unicode字符串方面，这些方法不是唯一改进，标准规范还添加了两个有用的语法元素。

## 正则表达式u修饰符

你可以使用正则表达式完成许多常用的字符串操作。但是记住，正则表达式是假设16位编码单元，每个编码单元代表一个单字符。为了解决这个问题，ECMAScript 6为正则表达式定义了一个`u`修饰符，代表Unicode。

### u标记实战

当正则表达式设置u修饰符后，它切换模式处理字符串，不是编码单元。这意味着，正则表达式不在对“代理对”感到迷惑，并且表现如期的行为。比如，看这段代码：

```js
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(/^.$/u.test(text));     // true
```

正则表达式`/^.$/`匹配任何输入的单字符组成的字符串。没有使用`u`修饰符时，这个正则表达式匹配编码单元，所以这个日文字符（它是用两个编码单元表示）不会匹配这个正则表达式。当使用`u`修饰符时，正则表达式比较字符串，而不是编码单元，所以这个日文字符可以匹配。

### 计算码点

不幸的是，ECMAScript 6没有添加一个方法，去计算一个字符串有多少码点，但是利用`u`标记，你可以使用正则表达式计算字符串的码点数，如下：

```js
function codePointLength(text) {
    var result = text.match(/[\s\S]/gu);
    return result ? result.length : 0;
}

console.log(codePointLength("abc"));    // 3
console.log(codePointLength("𠮷bc"));   // 3
```

这个例子使用全局使用Uncode的正则表达式，调用`match()`去检测`text`中的空格或非空格字符（使用`[\s\S]`确保模式匹配换行符）。只要有一个匹配，`result`为一个匹配值的数组，所以数组的长度就是字符串中码点的数目。在字符串中`"abc"`和`"𠮷bc"`都有三个字符，所以这个数组长度都是3。

尽管这个方法生效，但是它效率不高，尤其是运用在长字符串上。你也可以使用一个字符串迭代器（在第八章讨论）。一般情况下，无论什么时候，尽量少去计算码点。

### 检查是否支持u修饰符
因为`u`修饰符属于语法变化，在不兼容ECMAScript 6的JavaScript引擎中使用该语法，会报语法错误。检查是否支持`u`修饰符最安全的方式是使用函数，比如这个：

```js
function hasRegExpU() {
    try {
        var pattern = new RegExp(".", "u");
        return true;
    } catch (ex) {
        return false;
    }
}
```

这个函数调用`RegExp`构造器，将`u`修饰符作为参数传入。这种语法在以前的JavaScript引擎中也是有效的，如果不支持`u`修饰符，这个构造器将会抛异常。

如果你代码需要在老一代的JavaScript引擎上工作，当使用`u`修饰符时，一定要使用`RegExp`构造器。这将防止语法错误，允许你在不中止程序执行的情况下，选择性的检查和使用`u`修饰符。

## 其他字符串变动

JavaScript字符串总是落后于其他语言在字符串上类似的功能。在ECMAScript 5规范中，字符串才有`trim()`方法，比如，ECMAScript 6任然在添加新功能去扩展JavaScript解析字符串的能力。

### 检索字符串的方法

开发者已经在使用`index()`方法检索在其他字符串中的字符串，因为它是JavaScript引入的第一个字符串检索方法。ECMAScript 6包括了如下三个方法，这些方法设计用于这些场景：

 - 调用`includes()`时，如果在字符串的任何地方中检索到所指定的文本，该方法方法返回true，否则返回false。
 - 调用`startsWith()`时，如果指定文本是字符串的开头，该方法返回true，否则返回false。
 - 调用`endsWith()`时，如果指定文本是字符串的末尾，该方法返回true，否则返回false。

每个方法接收两个参数：要搜索的文本和可选的索引，索引用来指定在开始搜索的位置。当提供第二个参数时，`includes()`和`startsWith()`方法从字符串那个索引的位置开始匹配，`endsWith()`方法从字符串长度减去第二个参数的地方开始匹配。当第二个参数省略时，`includes()`和`startsWith()`方法从字符串的开头开始匹配，`endsWith()`方法则从字符串的末尾开始匹配。实际上，第二个参数最小化被搜索的字符串的数量。这里有一些例子，展示这三个方法的实际运用：

```js
var msg = "Hello world!";

console.log(msg.startsWith("Hello"));       // true
console.log(msg.endsWith("!"));             // true
console.log(msg.includes("o"));             // true

console.log(msg.startsWith("o"));           // false
console.log(msg.endsWith("world!"));        // true
console.log(msg.includes("x"));             // false

console.log(msg.startsWith("o", 4));        // true
console.log(msg.endsWith("o", 8));          // true
console.log(msg.includes("o", 8));          // false
```

前三个方法调用没有传入第二个参数，所以它们可能搜索整个字符串。最后三个方法调用只检查部分字符串。`msg.startsWith("o", 4)`调用从`msg`字符串索引为4的位置开始匹配，也就是“Hello”中的“o”。`msg.endsWith("o", 8)`调用也是从索引为4的位置开始匹配，因为字符串的长度（12）要减去第二个参数8。`msg.includes("o", 8)`调用是从索引为8的位置开始匹配，也就“world”中的“r”位置。

虽然这三个方法很容易检索去字符串的存在性，但是它们直返一个布尔值。如果你需要找出一个字符串在另外一个字符串中实际位置，需要使用`indexOf()`或者`lastIndexOf()`方法。

如果给`startsWith()`，`endsWith()`，`includes()`方法传入正则表达式而不是字符串，它们会报错。这`indexOf()`和`lastIndexOf()`方法相反，它们会把正则表达式参数转化为字符串，然后搜索该字符串。

### repeat()方法
ECMAScript 6 也给字符串添加了`repeat()`方法，它接收一个参数，这个参数用于指定复制字符串的次数。该方法返回一个新字符串，包含原始字符串指定次数的复制。比如：

```js
console.log("x".repeat(3));         // "xxx"
console.log("hello".repeat(2));     // "hellohello"
console.log("abc".repeat(4));       // "abcabcabcabc"
```

首先这个方法很方便，当你操作文本时很有用。尤其是代码格式化程序中，需要创建缩进等级，比如：

```js
// 指定缩进的空格数量
var indent = " ".repeat(4),
    indentLevel = 0;

// 当你增加缩进时
var newIndent = indent.repeat(++indentLevel);
```

第一个`repeat()`调用一个包含四个空格的字符串，`indentLevel`变量用来追踪缩进等级。然后，你可以传入递增的`indentLevel`调用`repeat()`方法，来改变空格数。

ECMAScript 6也对不适合特定场合的正则表达式的功能做一些有用的改动，下一节重点介绍几个。

## 其他正则表达式变化

正则表达式是JavaScript中处理字符串重要的一部分，和该编程语言的其他部分一样，在最近的版本中没有太多变化。然而，ECMAScript 6在升级字符串的同时，也对正则表达式做了一些改善。

### 正则表达式y修饰符
火狐浏览器实现`y`修饰，作为正则表达式的专有扩展，之后ECMAScript 6也把`y`作为了一种标准。`y`修饰符影响正则表达式搜索的`sticky`属性，它指示搜索在正则表达式的lastIndex属性指定的位置开始匹配字符串的字符。如果在那个位置没有匹配上，正则表达式就会停止匹配。要了解它是如何工作的，请看如下代码：

```js
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // Error! stickyResult is null
```

这个例子有三个正则表达式，`pattern`中的表达式没有修饰符，`globalPattern`中的表达式使用了`g`修饰符，`stickyPattern`中的表达式使用了`y`修饰符。在前三个console.log()调用中，三个正则表达式都返回了`"hello1 "`，该字符串末尾带一个空格。

之后，三个正则表达式的`lastIndex`属性都设置为1，这表示着，正则表达式应该从字符串的第二字符开始匹配。没有修饰符的正则表达式完全忽视`lastIndex`属性的改变，仍然不出意外匹配到`"hello1 "`。使用`g`修饰符的正则表达式继续匹配到"hello2 "，因为它是从字符串的第二个字符“e”往前搜索。粘性正则表达式从第二字符串开始搜索，没有匹配到任何字符串，所以“stickyResult”依旧为null。

每次执行操作室，粘性修饰符保存了`lastIndex`最后一次匹配的下一个字符的索引。如果操作的结果没有匹配上，`lastIndex`就会设置为0，全局修饰符也是同样的行为，如这里所示：

```js
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 7
console.log(stickyPattern.lastIndex);   // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // "hello2 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 14
console.log(stickyPattern.lastIndex);   // 14
```

对于stickyPattern和globalPattern变量，在第一次执行exec()之后，lastIndex的值变为7，第二次调用后变为14。有两个关于粘性修饰符的细节需要记住：

 1. 只有在调用正则表达式对象上的方法，才能使用lastIndex属性，比如exec()和test()方法，把正则表达式传给字符串的方法，比如match()，这不会导致粘性行为。
 2. 当使用^字符去匹配字符串的开头时，粘性正则表达式只会从字符串的开始匹配（或者是多行模式下，每行的开始）。当lastIndex的属性为0时，^使得粘性正则表达式和非粘性正则表达式没区别。如果在单行模式下，lastIndex属性不是对应字符串的开头，或者在多行模式下，不是对应一行的开头，粘性正则表达式将不会生效。

和其他正则表达式一样，你可以使用属性检测y修饰符的存在性。在这个例子中，你可以检测sticky属性，如下：

```js
var pattern = /hello\d/y;

console.log(pattern.sticky);    // true
```

如果存在粘性修饰符，sticky属性为true，否则为false。sticky属性是基于y修饰符存在的只读属性，不能再代码里修改。

和u修饰符一样，y修饰符是语法变化，在老的JavaScript引擎中，它可能造成语法错误。你可以使用如下方法去检查是否支持：

```js
function hasRegExpY() {
    try {
        var pattern = new RegExp(".", "y");
        return true;
    } catch (ex) {
        return false;
    }
}
```

就和`u`修饰符检验一样，如果不能创建一个带y修饰符的正则表达式，就返回false。最后一个和u修饰符相似之处，如果你需要在旧的JavaScript引擎中使用y修饰符，确保在定义这些正则表达式时，使用RegExp构造器去避免语法错误。

### 复制正则表达式
在ECMAScript 5中，你可以复制正则表达式，通过把他们传递到RegExp构造器中，比如：

```js
var re1 = /ab/i,
    re2 = new RegExp(re1);
```

re2变量只是re1变量的副本，但是如果你给RegExp构造器提供第二个参数，给正则表达式声明修饰函数，你的代码就不会生效了，比如：

```js
var re1 = /ab/i,

    // 在ES5中会报错，在ES6中不会
    re2 = new RegExp(re1, "g");
```

如果你在ECMAScript 5环境运行这段代码，你会收到一个错误，这表明当地一个参数是正则表达式式时，不能传入第二个参数。ECMAScript 6改变了这种行为，所以第二个参数是允许的，可以覆盖第一个参数中的任何修饰符。比如：

```js
var re1 = /ab/i,

    // 在ES5中会报错，ES6中不会
    re2 = new RegExp(re1, "g");


console.log(re1.toString());            // "/ab/i"
console.log(re2.toString());            // "/ab/g"

console.log(re1.test("ab"));            // true
console.log(re2.test("ab"));            // true

console.log(re1.test("AB"));            // true
console.log(re2.test("AB"));            // false
```

在这段代码中，res1有不区分大小写的i修饰符，同时re2只有全局g修饰符，RegExp构造器从re1复制模式，用g修饰符替代i修饰符。如果没有第二个参数，re2和re1的修饰符将会一样。

### flags属性

随着添加新的修饰符，改变修饰符工作的方式，ECMAScript 6添加了一个关联他们的属性。在ECMAScript 5中，你可以使用source属性得到正则表达式的文本，但是为了得到修饰符字符串，你必须解析toString()方法的输出，如下：

```js
function getFlags(re) {
    var text = re.toString();
    return text.substring(text.lastIndexOf("/") + 1, text.length);
}

// toString() is "/ab/g"
var re = /ab/g;

console.log(getFlags(re));          // "g"
```

这段代码把正则表达式转换为了字符串，然后返回在最后一个/之后的字符。这些都是修饰符。
