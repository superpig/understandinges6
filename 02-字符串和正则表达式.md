# 字符串和正则表达式

字符串可以说是编程中最重要的数据类型。他们几乎存在每个高级编程语言中，高效地使用字符串是开发者创建有用的程序的基础。通过扩展，正则表达式十分重要，因为正则表达式给开发者提供的额外的功能操作字符串。考虑到这些事实，ECMAScript 6的创建者通过增加新功能和长期确实的功能，改善字符串类型和正则表达式。这章将介绍这两种类型的变化。

## 更好的Unicode支持

在ECMAScript 6之前，JavaScript字符串是16位字符编码（UTF-16）。每16位序列为一个字符串的代码单元。所有的字符串属性和方法，比如`length`属性和`charAt()`，都是基于这些16位的代码单元。当然，使用16位字符编码足以包含任何字符。由于Unicode引进扩展字符，16位字符编码不再满足需求。

### UTF-16 码点

限制字符的长度为16位不可能满足Unicode的目标，既给全世界的每一个字符提供唯一的编号。这些唯一的编号，被称为*码点*，他们都是从0开始的简单数字。码点是你们认为的字符代码，其中一个数标识一个字符。字符串编码必须将代码点编码为内部一致的代码单元。对于UTF-16，码点可以组成许多代码单元。

UTF-16中的前2^16个码点代表单个的16位代码单元。这区间称为*基本平面*(BMP)。之外的字符都放在 *辅助平面* ，*辅助平面* 的码点不只是16位。UTF-16为了解决这个问题引入*“代理对”* ，单码点用两个16位代码单元表示。这就意味着字符串中任何单字符，要么是基本平面字符集中一个代码单元，总共16位，要么是辅助平面字符集的的两个单元，总共32位。

在ECMAScript 5中，所有的字符操作基于16位代码单元工作，意味着在获取包含“代理对”的UTF-16编码字符串时，你可能得到出乎意料的结果，比如这个例子：

```js
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""
console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
```

单个Unicode字符`“𠮷”`使用代理对，因此，JavaScript字符操作在处理这个字符串时，将把它视为两个16位的字符。这表示：

 - `text`的长度为2，即使它应该是1。
 - 正则表达式不能匹配单字符，因为它会认为有两个字符。
 - `charAt()`不能返回有效的字符串，两个16位字符都不符合可打印的字符串

`charCodeAt()`方法也不能识别这个字符。它能对每个代码单元返回准确的16位数，但这是你在ECMAScript 5中最有可能得到`text`的真实值的方法。

另一方面，ECMAScript 6强制UTF-16字符串编码来解决这些问题。标准的字符串操作基于这种字符编码，这表示JavaScript可以支持专用于“代理对”的功能。本节的其余部分将讨论该功能的几个关键示例。

### codePointAt()方法

codePointAt()方法是ECMAScript 6为了完全支持UTF-16新添加的一个方法，它通过给定的一个字符串中的位置去匹配，取出Unicode码点。这个方法接收的是代码单元的位置，而不是字符的位置，并且返回一个整数值，比如示例中的这些`console.log()`:

```js
var text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```

除了non-BMP的字符集，`codePointAt()`方法和`charCodeAt()`方法返回值相同，`text`中的第一个字符是non-BMP字符，所以它是由两个代码单元组成，表示`length`属性的值为3，而不是2。`charCodeAt()`方法只返回位置为0的代码单元，但是codePointAt()返回完整的码点，即使码点跨越多个代码单元。两个方法都对位置1（第一个字符的第二个代码单元）和位置2（`“a”`字符）返回了相同的值。

在字符上调用`codePointAt()`是检验字符是否由一个或者两个码点表示的最简便方法。你可以写这个函数去检验：

```js
function is32Bit(c) {
    return c.codePointAt(0) > 0xFFFF;
}

console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false
```

16位字符的上限用十六进制表示为`FFFF`，所以任何在FFFF之上的码点必须由两个代码单元表示，总共32位。
