# 函数

函数是任何编程语言的重要组成部分，在ECMAScript 6之前，从这门语言诞生起，JavaScript的函数没有太多的改变。这留下了一堆问题和更容易犯错的微妙行为，而且经常需求更多代码去实现十分基本的行为。

考虑JavaScript开发者多年的抱怨和请求，ECMAScript 6的函数向前迈了一大步。结果是在ECMAScript 5函数的基础上，有许多增量式的改进，这让JavaScript编程更少出错，更加强大。

## 带默认参数的函数

JavaScript中的函数是十分独特的，不管已经在函数定义中声明了参数个数，函数还是允许传入任何数量的参数。这允许你定义函数，这个函数可以处理不同数量的参数，当没有提供参数时，通常只要填充默认值。这部分内容覆盖了在ECMAScript 6以及之前默认参数如何工作，这部分内容有关于arguments对象的重要内容，使用表达式作为参数，以及另外一个TDZ。

### 在ECMAScript 5中模仿默认参数

在ECMAScript 5和更早以前，你可能会使用如下模式创建一个带有默认参数的函数：

```js
function makeRequest(url, timeout, callback) {

    timeout = timeout || 2000;
    callback = callback || function() {};

    // 函数的其他部分

}
```

在这例子中，timeout和callback实际上都是可选的，因为如果没有提供参数，他们会赋予一个默认值。逻辑或操作（||）在第一个参数的布尔值为false的情况下，通常会返回第二个操作数。命名函数的参数没有提供情况下，会设置为undefined，逻辑或操作经常用来给缺少的参数提供默认值。然而，这个方法有一个缺陷，timeout的有效值实际上有可能为0，但是这个方法会把0替换为2000，因为0的布尔值是false。

这种情况下，一个更加安全的替代方案是使用typeof检验参数的类型，比如这个例子：

```js
function makeRequest(url, timeout, callback) {

    timeout = (typeof timeout !== "undefined") ? timeout : 2000;
    callback = (typeof callback !== "undefined") ? callback : function() {};

    // 函数的其余部分

}
```

虽然这个方案更加安全，但是它仍然需要大量额外的代码去完成一个十分基本的操作。流行的JavaScript库也使用这种模式，因为这代表了一种常见的模式。

### 在ECMAScript 6中的默认参数值

ECMAScript 6通过提供初始化，给参数提供默认值更加容易。当参数没有正式传入时，就会调用初始化。比如:

```js
function makeRequest(url, timeout = 2000, callback = function() {}) {

    // 函数的其他部分

}
```

这个函数只需要传入第一个参数。其他两个参数有默认值，这让函数体更加小，因为你不需要添加任何代码去检查缺失的值。

当传入三个参数调用makeRequest()时，默认值不会被使用。比如：

```js
// 使用默认的timeout和callback
makeRequest("/foo");

// 使用默认的callback
makeRequest("/foo", 500);

// 不适用默认值
makeRequest("/foo", 500, function(body) {
    doSomething(body);
});
```

ECMAScript 6认为url是必传参数，这就为什么在makeRequest()的三次调用中都传入了"/foo"。带有默认值的两个参数是可选的。

可以对任何参数制定默认值，包括在函数声明里，没有默认值的参数之前的那些参数。比如，这也是可以的：

```js
function makeRequest(url, timeout = 2000, callback) {

    // 函数的其余部分

}
```

在这种情况下，如果没有传入第二参数或者第二个参数明确作为undefined传入，才会使用timeout的默认值。比如这个例子：

```js
// 使用timeout默认值
makeRequest("/foo", undefined, function(body) {
    doSomething(body);
});

// 使用timeout默认值
makeRequest("/foo");

// 不使用timeout默认值
makeRequest("/foo", null, function(body) {
    doSomething(body);
});
```

在默认参数值的情况下，null的值是被认为有效的，这表示在第三个makeRequest()的调用中，不会使用timeout的默认值。

### 默认参数值如何影响argument对象

只要记住，当默认参数值出现时，arguments对象的行为是不一样的。在ECMAScript 5非严格模式下，arguments对象反应的是一个函数中命名参数的改变。这里有一些代码阐述它工作原理：

```js
function mixArgs(first, second) {
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d";
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
```

输出：

```js
true
true
true
true
```

arguments对象总是在非严格模式中更新，来反映命名参数的更改。所以当first和second变量赋予新值时，arguments[0]和arguments[1]也因此更新，使得所有的===比较都为true。

然而ECMAScript 5的严格模式消除了arguments对象混乱的地方。在严格模式下，arguments对象没有反应命名参数的改变。这里又是mixArgs()函数，但是是在严格模式下：

```js
function mixArgs(first, second) {
    "use strict";

    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
```

调用mixArgs()的输出：

```js
true
true
false
false
```

这次改变first和second变量没有影响arguments，所以输出和你期待的结果一样。

然而，在函数中使用ECMAScript 6默认参数值，arguments对象的行为通常和在ECMAScript 5严格模式下是一样的，不管这个函数是否明确地运行在严格模式中。默认参数值的出现会arguments对象和命名参数保持分离。这是一个细小但是很重要的细节，因为这关系到如何使用arguments对象。考虑一下代码：

```js
// 不在严格模式下
function mixArgs(first, second = "b") {
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a");
```

输出：

```js
1
true
false
false
false
```

在这个例子中，arguments.length为1，因为只有一个参数传入mixArgs()。那也表示arguments[1]是undefined，当只有一个参数传入函数时，这是期待的结果。也表示first变量值和arguments[0]相等。改变first和second对arguments没有影响。这种行为在非严格和严格模式下都会发生，所以你可以依赖arguments去反映初始调用状态。

### 默认参数表达式

也许默认参数值最有趣的特性是默认值不需要原始值。比如，你可以执行一个函数去提取默认参数值，像这样：

```js
function getValue() {
    return 5;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
```

这里，如果最后一个参数没有提供，getValue函数不会被调用去获取正确的默认值。记住，当add()函数在没有传入第二个参数被调用的时候，getValue()才会被调用，不是在函数声明第一次解析的时候。这意味着，如果getValue()写法不同，它可能潜在地会返回不同的值。比如：

```js
let value = 5;

function getValue() {
    return value++;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
console.log(add(1));        // 7
```

在这例子中，value的值开始为5，每次调用getValue()自增1。第一次调用add(1)返回6，然而第二次调用add(1)返回7，因为value的值增加了。因为second变量的默认值只有当这函数被调用时才会求值，可以随时改变该值。

在使用函数调用作为默认参数值时要小心。如果你忘记写括号，比如在最后一个例子中，second = getValue，你传递的是一个函数引用，而不是函数调用结果。

这个行为引入另外一个有趣的功能。你可以使用前一个参数作为后一个参数的默认值。这里有个例子：

```js
function add(first, second = first) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
```

在这段代码中，first的值作为了second参数的默认值，意味着只传入一个参数，两个参数都会有相同的值。所以add(1, 1)返回2就像add(1)返回2。进一步，你可以把first传入一个函数去获取second的默认值，如下：

```js
function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
```

这个例子设置second为getValue(first)返回的值，所以当add(1, 1)依然返回2，add(1)返回7（1+6）。

从默认参数分配中引用参数的功能只对前一个参数生效，所以前面的参数不能访问后面的参数。比如：

```js
function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // throws error
```

调用add(undefined, 1)会抛出一个错误，因为second是在first之后定义的，所以不能访问来作为默认值。为了理解为什么发生这种情况，有必要再复习一下暂时盲区。

### 默认参数值暂时盲区

第一章介绍了暂时盲区（TDZ），它是和let和const相关，而且默认参数值也有暂时盲区(TDZ)的概念，在这暂时盲区里，参数无法被访问。和let声明相似，每个参数创建一个新的标识符绑定，在初始化之前不能被引用，也不会报错。在函数被调用时，进行参数初始化，要么是通过给参数传值，要么是使用默认参数值。

为研究默认参数值的TDZ，看一下这个例子，这例子又是来自“默认参数表达式”那节内容：

```js
function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
```

调用add(1, 1)和add(1)高效地执行了如下代码，创建了first和second的参数值：

```js
// 调用add(1, 1)的JavaScript表现形式
let first = 1;
let second = 1;

// 调用add(1)的JavaScript表现形式
let first = 1;
let second = getValue(first);
```

当add()函数第一次执行时，first和second绑定被添加到一个特定参数的暂时盲区（和let如何工作很相似）。所以可以使用first的值初始化second，因为通常在那个时候，first已经初始化了，相反不行。现在，考虑重写add()函数：

```js
function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // 报错
```

现在这个例子中，调用add(1, 1)和add(undefined, 1)在幕后等同于这段代码：

```js
// 调用add(1, 1)的JavaScript表现形式
let first = 1;
let second = 1;

// 调用add(undefined, 1)的JavaScript表现形式
let first = second;
let second = 1;
```

在这个例子中，调用add(undefined, 1)会报错，因为当first参数初始化时，second参数还没有初始化。在那个时刻，second参数在暂时盲区中，所以second参数的任何引用都会报错。这反映了我们第一章讨论的let绑定的行为。

函数参数有他们自己的作用域和暂时盲区，这是和函数体的作用域是分开的。那就意味着，参数的默认值不能访问在函数体内的任何变量声明。

### 使用无名参数

到现在，这章的例子只覆盖了在函数定义中命名的参数。然而，JavaScript函数没有限制可以传给命名参数的参数数量。你通常可以传递比正式定义的参数更少或者更多的参数。当函数接受更少的参数，默认参数值可以让它更清晰，而且ECMAScript 6也在试图解决传递比定义更多的参数的问题。

#### ECMAScript 5中的无名参数

早期，JavaScript提供了arguments对象，作为一种查询所有传递的函数参数的方式，不需要每个参数单独定义。比如，看这段代码，它查询了arguments对象：

```js
function pick(object) {
    let result = Object.create(null);

    // 从第二个参数开始
    for (let i = 1, len = arguments.length; i < len; i++) {
        result[arguments[i]] = object[arguments[i]];
    }

    return result;
}

let book = {
    title: "Understanding ECMAScript 6",
    author: "Nicholas C. Zakas",
    year: 2015
};

let bookData = pick(book, "author", "year");

console.log(bookData.author);   // "Nicholas C. Zakas"
console.log(bookData.year);     // 2015
```

这个函数模仿了Underscore.js库中的pick()方法，这个返回一个传入的对象的拷贝对象，这个拷贝对象包含原始对象属性的一些指定子集。这个例子只定义了一个参数，并且期待第一个参数是一个可以拷贝属性的对象。传递的其他 每个参数都是属性名，它们要被复制到结果中。

关于pick()函数有一些事情需要注意。首先，这个函数可以处理不止一个参数的特征不是很明显。你可以定义更多的参数，但是你没有办法表示这个函数可以使用任意数量的参数。其次，第一个参数是命名的，而且是直接使用，当你为复制去查找属性时，你必须从arguments对象索引为1的位置开始，而不是索引为0的位置。记住，使用arguments正确的索引不是很难，但是他是一个要跟踪的事情。

ECMAScript 6引入rest参数去帮助解决这些问题。

### Rest参数

在命名参数前面加三个点（...）表示rest参数，那个命名参数就变成了一个数组，这个数组包含了传入函数的其余参数，这就是命名“rest”参数起源。比如，pick()函数可以使用rest参数重写，如下：

```js
function pick(object, ...keys) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
```

在这个版本中，keys是一个rest参数，它包含在object之后的所有参数（不像arguments，包含了所有的参数，包括第一个参数）。这就表示你可以毫无忌惮地遍历keys。作为奖励，通过查看这个函数，你就可以知道这个函数可以处理任何数量的参数。

rest参数不会影响函数的长度属性，这个属性表示该函数命名参数的数量。在这例子中，pick()函数的length值为1，因为只有object参数计算到这个值中。

#### rest参数的限制

在rest参数上有两个限制。第一个限制是有且只能有一个rest参数，而且rest参数必须在参数列表最后。比如，这段代码不会生效：

```js
// 语法错误，在rest参数后面不能有命名参数
function pick(object, ...keys, last) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i < len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
```

这里，last参数在rest参数keys之后，将会造成一个语法错误。

第二个限制是，rest参数不能在对象字面量的setter中使用。这就表示下面这段代码也会造成语法错误：

```js
let object = {

    // 语法错误，不能在setter中使用rest参数
    set name(...value) {
        // do something
    }
};
```

这个限制之所以存在，是因为对象字面的setter被限制为一个参数。在定义中，rest参数表示无限多个参数，所以rest参数在这个context是不允许的。

#### rest参数如何影响arguments对象

在ECMAScript中，rest参数是为了替换arguments对象。最早是ECMAScript 4要废弃arguments，添加rest参数去允许给函数传递无限制数量的参数。虽然ECMAScript 4没有发布，但是这想法一致保留着，并且在ECMAScript中重新引入，尽管arguments没有从JavaScript中移除。

通过映射传入函数的参数，arguments对象和rest参数可以一起生效。如这个程序展示：

```js
function checkArgs(...args) {
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0], arguments[0]);
    console.log(args[1], arguments[1]);
}

checkArgs("a", "b");
```

调用chekArgs()方法输出：

```js
2
2
a a
b b
```

不管是否使用rest参数，arguments对象都能正确地映射传入函数的参数。

这就是在开始使用rest参数之前，需要了解的全部内容。

## 增强Function构造函数的能力

Function 构造函数是JavaScript的一个不常用的部分，它允许你动态创建一个新的函数。构造函数的参数是函数和函数体的参数，都是字符串。这里有一个例子：

```js
var add = new Function("first", "second", "return first + second");

console.log(add(1, 1));     // 2
```

ECMAScript 6 增强了Function构造函数的能力，允许传递默认参数和rest参数。你只需要给参数名添加一个等号和一个值，如下：

```js
var add = new Function("first", "second = first",
        "return first + second");

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
```

在这例子中，当只传入一个参数时，参数second赋值为first。这种语法和不适用Function的函数声明是一样的。

对于rest参数，只需要在最后一个参数之前加`...`，比如：

```js
var pickFirst = new Function("...args", "return args[0]");

console.log(pickFirst(1, 2));   // 1
```

这段代码创建了一个函数，它只使用了一个rest参数，并且返回传入的第一个参数。

增加默认参数和rest参数，确保Function具有和创建函数声明形式相同的功能。

## 传播操作符（Spread Operator）
和rest参数紧密相关的是传播操作符。rest参数允许你指定多个独立的参数应该组合到一个数组中，传播操作符允许你指定一个数组，应该分割这个数组，让它的每项作为独立的参数传递给函数。看下`Math.max()`方法，它接受任何数量的参数，然后返回最大值。这里有一个关于这个方法简单的用例：

```js
let value1 = 25,
    value2 = 50;

console.log(Math.max(value1, value2));      // 50
```

当你只处理两个值时，就像这个例子，`Math.max()`很容易使用。出入两个值，返回更大的值。但是如果你在追踪数组中的值，并且你想找出其中最大的值？`Math.max()`方法不允许你传入一个数组，所以在ECMAScript 5和更早版本中。你会被阻塞，要么自己检索数组，要么使用 `apply()`，如下：

```
let values = [25, 50, 75, 100]

console.log(Math.max.apply(Math, values));  // 100
```
这方案有用，但是在场景使用`apply()`有点混乱。它实际上好像通过使用附加语法，模糊了代码的真正意图。

The ECMAScript 6的传播操作符让这种场景变得非常简单。而不是使用`apply()`，你可以直接给`Math.max()`传递一个数组，并且使用与rest参数相同的...模式前缀。然后JavaScript引擎会分割这个数组为单个参数，将它们传入，像这样：

```js
let values = [25, 50, 75, 100]

// 等价于
// console.log(Math.max(25, 50, 75, 100));
console.log(Math.max(...values));           // 100
```

想在调用`Math.max()`看起来更符合常规，并且避免给一个简单的数学运算指定this绑定（上一个例子中，`Math.max.apply()`的第一个参数）的复杂性。你也可以与其他参数混合使用和匹配传播操作符。假设你想让`Math.max()`返回最小的数为0（只是为了防止负数进入数组）。你可以单独传递那个参数，仍旧可以对其他参数使用传播操作符，如下：

```
let values = [-25, -50, -75, -100]

console.log(Math.max(...values, 0));        // 0
```
在这个例子中，传递给`Math.max()`的最后一个参数是0，它在使用传播操作符的其他参数之后。

参数传递的传播操作符让使用数组的函数参数更加容易。你可能会发现，在大部分场景里，它适合替换`apply`。

除了目前为止，你看到的默认和rest参数，在ECMAScript 6中，你也可以将这两种参数类型运用于JavaScript的Funciton构造函数。


## ECMAScript 6的名称属性(name Property)
在JavaScript中函数能够以各种方式定义，所以识别函数是很具有挑战性的。另外，匿名函数的普及让调试更困难，经常导致难以读取和解密堆栈追踪。因为这些原因，ECMAScript 6给所有的函数增加了名称属性。

### 选择适当的名称
ECMAScript 6程序中的所有函数对他们名称属性都有一个适当的值。为了在实际应用中看到这点，看下面这个例子，它显示了函数和函数表达式，并且打印了它们的名称属性：

```js
function doSomething() {
    // ...
}

var doAnotherThing = function() {
    // ...
};

console.log(doSomething.name);          // "doSomething"
console.log(doAnotherThing.name);       // "doAnotherThing"
```

在这段代码中，`doSomething()`有一个名称属性为 “doSomething”，因为它是一个函数声明。这个匿名函数表达式`doAnotherThing()`有一个“doAnotherThing”的名称，因为这是匿名函数表达式赋值的变量的名称。

### 名称函数的特殊情况
虽然函数声明和函数表达式的相应名称很容易找到，但是ECMAScript 6进一步确保所有的函数具有合适的名称。为了说明这点，想想下面的程序：

```js
var doSomething = function doSomethingElse() {
    // ...
};

var person = {
    get firstName() {
        return "Nicholas"
    },
    sayName: function() {
        console.log(this.name);
    }
}

console.log(doSomething.name);      // "doSomethingElse"
console.log(person.sayName.name);   // "sayName"

var descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
console.log(descriptor.get.name); // "get firstName"
```

在这个例子中，doSomething.name是“doSomethingElse”，因为函数表达式本身有一个名称，而且这个名称的优先级要高于分配函数的变量。`person.sayName()`的名称属性是“sayName()”，因为这个值是从对象字面量解析得到的。相似地，person.firstName实际上是一个getter函数，因此它的名称是“get firstName”以表示此差异。setter函数也以“set”作为前缀。（getter和setter函数都必须使用Object.getOwnPropertyDescriptor()检索。）

还有一些其他的特殊情况下的函数名称。使用bind()创建的函数有它们的前缀“bound”，还有使用Function构造函数创建的函数有“anonymous”的名称，比如这个例子：

```js
var doSomething = function() {
    // ...
};

console.log(doSomething.bind().name);   // "bound doSomething"

console.log((new Function()).name);     // "anonymous"
```

绑定函数的name通常是要绑定的函数的名称，前缀是字符串“bound”，因此`doSomething()`的绑定版本是“bound doSomething”。

请记住，任何函数的name的值不一定引用相同名称的变量。名称属性旨在提供信息，帮助调试，所以没有办法使用name的值去获取函数的引用。
